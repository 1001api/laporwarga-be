// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: categories.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkCategoryExist = `-- name: CheckCategoryExist :one
SELECT EXISTS (
    SELECT 1 
    FROM categories 
    WHERE name = $1 OR slug = $2
)
`

type CheckCategoryExistParams struct {
	Name string `db:"name" json:"name"`
	Slug string `db:"slug" json:"slug"`
}

func (q *Queries) CheckCategoryExist(ctx context.Context, arg CheckCategoryExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCategoryExist, arg.Name, arg.Slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (
    name, 
    slug,
    icon,
    color,
    is_active,
    sort_order
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) RETURNING id
`

type CreateCategoryParams struct {
	Name      string      `db:"name" json:"name"`
	Slug      string      `db:"slug" json:"slug"`
	Icon      pgtype.Text `db:"icon" json:"icon"`
	Color     pgtype.Text `db:"color" json:"color"`
	IsActive  pgtype.Bool `db:"is_active" json:"is_active"`
	SortOrder pgtype.Int4 `db:"sort_order" json:"sort_order"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.Name,
		arg.Slug,
		arg.Icon,
		arg.Color,
		arg.IsActive,
		arg.SortOrder,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteCategory = `-- name: DeleteCategory :one
UPDATE categories
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL 
RETURNING id
`

func (q *Queries) DeleteCategory(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteCategory, id)
	err := row.Scan(&id)
	return id, err
}

const getCategories = `-- name: GetCategories :many
SELECT 
    id,
    name,
    slug,
    icon,
    color,
    is_active,
    sort_order,
    created_at,
    updated_at
FROM categories
WHERE is_active = TRUE AND deleted_at IS NULL
ORDER BY sort_order ASC
`

type GetCategoriesRow struct {
	ID        uuid.UUID          `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	Slug      string             `db:"slug" json:"slug"`
	Icon      pgtype.Text        `db:"icon" json:"icon"`
	Color     pgtype.Text        `db:"color" json:"color"`
	IsActive  pgtype.Bool        `db:"is_active" json:"is_active"`
	SortOrder pgtype.Int4        `db:"sort_order" json:"sort_order"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetCategories(ctx context.Context) ([]GetCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoriesRow{}
	for rows.Next() {
		var i GetCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Icon,
			&i.Color,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryById = `-- name: GetCategoryById :one
SELECT 
    id,
    name,
    slug,
    icon,
    color,
    is_active,
    sort_order,
    created_at,
    updated_at
FROM categories
WHERE id = $1 AND deleted_at IS NULL
`

type GetCategoryByIdRow struct {
	ID        uuid.UUID          `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	Slug      string             `db:"slug" json:"slug"`
	Icon      pgtype.Text        `db:"icon" json:"icon"`
	Color     pgtype.Text        `db:"color" json:"color"`
	IsActive  pgtype.Bool        `db:"is_active" json:"is_active"`
	SortOrder pgtype.Int4        `db:"sort_order" json:"sort_order"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetCategoryById(ctx context.Context, id uuid.UUID) (GetCategoryByIdRow, error) {
	row := q.db.QueryRow(ctx, getCategoryById, id)
	var i GetCategoryByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Icon,
		&i.Color,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT 
    id,
    name,
    slug,
    icon,
    color,
    is_active,
    sort_order,
    created_at,
    updated_at
FROM categories
WHERE slug = $1 AND deleted_at IS NULL
`

type GetCategoryBySlugRow struct {
	ID        uuid.UUID          `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	Slug      string             `db:"slug" json:"slug"`
	Icon      pgtype.Text        `db:"icon" json:"icon"`
	Color     pgtype.Text        `db:"color" json:"color"`
	IsActive  pgtype.Bool        `db:"is_active" json:"is_active"`
	SortOrder pgtype.Int4        `db:"sort_order" json:"sort_order"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (GetCategoryBySlugRow, error) {
	row := q.db.QueryRow(ctx, getCategoryBySlug, slug)
	var i GetCategoryBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Icon,
		&i.Color,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchCategories = `-- name: SearchCategories :many
SELECT 
    id,
    name,
    slug,
    icon,
    color,
    is_active,
    sort_order,
    created_at,
    updated_at
FROM categories
WHERE name ILIKE '%' || $1::text || '%' AND deleted_at IS NULL
ORDER BY 
    CASE WHEN $2::text = 'name'       AND $3::text = 'ASC'  THEN name       END ASC,
    CASE WHEN $2::text = 'name'       AND $3::text = 'DESC' THEN name       END DESC,
    CASE WHEN $2::text = 'slug'       AND $3::text = 'ASC'  THEN slug       END ASC,
    CASE WHEN $2::text = 'slug'       AND $3::text = 'DESC' THEN slug       END DESC,
    CASE WHEN $2::text = 'icon'       AND $3::text = 'ASC'  THEN icon       END ASC,
    CASE WHEN $2::text = 'icon'       AND $3::text = 'DESC' THEN icon       END DESC,
    CASE WHEN $2::text = 'color'      AND $3::text = 'ASC'  THEN color      END ASC,
    CASE WHEN $2::text = 'color'      AND $3::text = 'DESC' THEN color      END DESC,
    CASE WHEN $2::text = 'is_active'  AND $3::text = 'ASC'  THEN is_active  END ASC,
    CASE WHEN $2::text = 'is_active'  AND $3::text = 'DESC' THEN is_active  END DESC,
    CASE WHEN $2::text = 'sort_order' AND $3::text = 'ASC'  THEN sort_order END ASC,
    CASE WHEN $2::text = 'sort_order' AND $3::text = 'DESC' THEN sort_order END DESC
`

type SearchCategoriesParams struct {
	SearchTerm string `db:"search_term" json:"search_term"`
	SortBy     string `db:"sort_by" json:"sort_by"`
	SortOrder  string `db:"sort_order" json:"sort_order"`
}

type SearchCategoriesRow struct {
	ID        uuid.UUID          `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	Slug      string             `db:"slug" json:"slug"`
	Icon      pgtype.Text        `db:"icon" json:"icon"`
	Color     pgtype.Text        `db:"color" json:"color"`
	IsActive  pgtype.Bool        `db:"is_active" json:"is_active"`
	SortOrder pgtype.Int4        `db:"sort_order" json:"sort_order"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) SearchCategories(ctx context.Context, arg SearchCategoriesParams) ([]SearchCategoriesRow, error) {
	rows, err := q.db.Query(ctx, searchCategories, arg.SearchTerm, arg.SortBy, arg.SortOrder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCategoriesRow{}
	for rows.Next() {
		var i SearchCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Icon,
			&i.Color,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleCategoryActiveStatus = `-- name: ToggleCategoryActiveStatus :one
UPDATE categories
SET is_active = NOT is_active
WHERE id = $1 AND deleted_at IS NULL 
RETURNING id, is_active
`

type ToggleCategoryActiveStatusRow struct {
	ID       uuid.UUID   `db:"id" json:"id"`
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
}

func (q *Queries) ToggleCategoryActiveStatus(ctx context.Context, id uuid.UUID) (ToggleCategoryActiveStatusRow, error) {
	row := q.db.QueryRow(ctx, toggleCategoryActiveStatus, id)
	var i ToggleCategoryActiveStatusRow
	err := row.Scan(&i.ID, &i.IsActive)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET 
    name = CASE
        WHEN $1::text IS NOT NULL AND $1::text != name THEN $1::text
        ELSE name
    END,
    slug = CASE
        WHEN $2::text IS NOT NULL AND $2::text != slug THEN $2::text
        ELSE slug
    END,
    icon = CASE
        WHEN $3::text IS NOT NULL AND $3::text != icon THEN $3::text
        ELSE icon
    END,
    color = CASE
        WHEN $4::text IS NOT NULL AND $4::text != color THEN $4::text
        ELSE color
    END,
    is_active = CASE
        WHEN $5::boolean IS NOT NULL AND $5::boolean != is_active THEN $5::boolean
        ELSE is_active
    END,
    sort_order = CASE
        WHEN $6::integer IS NOT NULL AND $6::integer != sort_order THEN $6::integer
        ELSE sort_order
    END
WHERE id = $7 AND deleted_at IS NULL 
RETURNING id
`

type UpdateCategoryParams struct {
	Name      string    `db:"name" json:"name"`
	Slug      string    `db:"slug" json:"slug"`
	Icon      string    `db:"icon" json:"icon"`
	Color     string    `db:"color" json:"color"`
	IsActive  bool      `db:"is_active" json:"is_active"`
	SortOrder int32     `db:"sort_order" json:"sort_order"`
	ID        uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.Name,
		arg.Slug,
		arg.Icon,
		arg.Color,
		arg.IsActive,
		arg.SortOrder,
		arg.ID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
